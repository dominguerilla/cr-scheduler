# Detects overlapping shifts between consultants and supervisors
# Returns a list of cons objects that contain:
# cons(netid of cons, {list of sups that overlap at some point})
def detectoverlap(allshifts):
    sups, cons = allshifts

    # list of cons(netid, {sups that overlap}) objects
    consoverlaps = createtuplelist(cons)

    # Checking for the actual overlaps
    # PSEUDOCODE START
    #if cons[i].start <= sups[j].end and cons[i].end >= sups[j].start:
        # find cons netid in overlaplist
        #k = 0
        #while overlaplist[k].netid != cons[i].netid:
            #k = k + 1
        # add the netid of the overlapping sup to the cons overlap list
        #overlaplist[k].suplist = sups[j].netid

    # sort list in ascending order of number of sups in cons suplist
    #sort(overlaplist, len(overlaplist.suplist)) 
    # PSEUDOCODE END

    for conshift in cons:
        # get the tuple from the consoverlaps list with the netid of this cons 
        constuple = [c for c in consoverlaps if c[0] == conshift.netID]
        for supshift in sups:
            # If the cons shift overlaps with the sup shift....
            if conshift.start <= supshift.end and conshift.end >= supshift.start:
                # ...and the constuple doesn't already have that sup....
                if not supshift.netID in constuple[1]:
                    constuple[1].append(supshift.netID)

    return consoverlaps

# Assigns cons to sups based on overlaplist generated by detectoverlap
def assignshift(overlaplist):
    # import text file containing all sups
    suplist = []
    return

# Given an input list of Shift objects,
# returns a list of unique tuples <netid, []>
def createtuplelist(shiftlist):
    tuplelist = []
    for shift in shiftlist:
        if not shift.netID in [t[0] for t in tuplelist]:
            tuplelist.append((shift.netID, []))
    return tuplelist